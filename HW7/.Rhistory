url<-URLencode(google.url)
apiResult<-getURL(url)
geoStruct<- fromJSON(apiResult, simplify=FALSE)
lat<-NA
lng<-NA
try(lat<-geoStruct$results[[1]]$geometry$location$lat)
try(lng<-geoStruct$results[[1]]$geometry$location$lng)
return(c(lat,lng))
}
#
#############################################################################
#############################Problems Solved#################################
#############################################################################
#
#
#Step 1: Load the data
#We will use the air quality data set, which you should already have as part of your R installation.
local.airquality<-airquality
local.airquality
na.numeric<-function(vector){
vector.length<-length(vector)
count<-NULL
while (count != vector.length){
if (vector[count] = NA){
vector[count]<-mean(vector)
count<-count+1
}else{
vector[count]<-vector[count]
count<-count+1
}
}
}
na.numeric<-function(vector){
vector.length<-length(vector)
count<-NULL
while (count != vector.length){
if (vector[count] = NA){
vector[count]<-mean(vector)
count<-count+1}
else{
vector[count]<-vector[count]
count<-count+1}
}
}
na.numeric<-function(vector){
vector.length<-length(vector)
count<-NULL
while (count != vector.length){
if (vector[count] = NA){
vector[count]<-mean(vector)
count<-count+1}
else{
vector[count]<-vector[count]
count<-count+1}
}
}
na.numeric<-function(vector){
vector.length<-length(vector)
count<-0
while (count != vector.length){
if (vector[count] = NA){
vector[count]<-mean(vector)
count<-count+1}
else{
vector[count]<-vector[count]
count<-count+1}
}
}
na.numeric<-function(vector){
vector.length<-length(vector)
count<-0
while (count != vector.length){
if (vector[count] = NA){
vector[count]<-mean(vector)
count<-count+1}
else{
vector[count]<-vector[count]
count<-count+1}
}
}
na.numeric<-function(vector){
vector.length<-length(vector)
count<-0
while (count != vector.length){
if (vector[count]=NA){
vector[count]<-mean(vector)
count<-count+1
}else{
vector[count]<-vector[count]
count<-count+1
}
}
}
View(vector)
na.numeric<-function(vector){
vector.length<-length(vector)
place<-0
while (place != vector.length){
if (vector[place]=NA){
vector[place]<-mean(vector)
place<-place+1
}else{
vector[place]<-vector[place]
place<-place+1
}
}
}
na.numeric<-function(vector){
for(i in vector){
vector[i]<-mean(vector)
}
return(vector)
}
#
#############################################################################
#############################Problems Solved#################################
#############################################################################
#
#
#Step 1: Load the data
#We will use the air quality data set, which you should already have as part of your R installation.
#
local.airquality<-airquality
#
#Step 2: Clean the data
#After you load the data, there will be some NAs in the data. You need to figure out what to do
#about those nasty NAs.
#
local.airquality$Ozone
print(na.numeric(local.airquality$Ozone))
#
#Step 2: Clean the data
#After you load the data, there will be some NAs in the data. You need to figure out what to do
#about those nasty NAs.
#
local.airquality$Ozone
#
#############################################################################
#############################Problems Solved#################################
#############################################################################
#
#
#Step 1: Load the data
#We will use the air quality data set, which you should already have as part of your R installation.
#
local.airquality<-airquality
#
#Step 2: Clean the data
#After you load the data, there will be some NAs in the data. You need to figure out what to do
#about those nasty NAs.
#
local.airquality$Ozone
local.airquality$Ozone(1)
local.airquality$Ozone[1]
local.airquality$Ozone[5]
local.airquality$Ozone[5]<-mean(local.airquality$Ozone)
local.airquality$Ozone[5]
mean
arg(mean)
mean?
mean()?
mean()
local.airquality$Ozone[5]<-mean(local.airquality$Ozone, na.rm=TRUE)
local.airquality$Ozone[5]
#
#############################################################################
#############################Problems Solved#################################
#############################################################################
#
#
#Step 1: Load the data
#We will use the air quality data set, which you should already have as part of your R installation.
#
local.airquality<-airquality
na.numeric<-function(vector){
for(i in vector){
vector[i]<-mean(vector, na.rm=TRUE)
}
return(vector)
}
print(na.numeric(local.airquality$Ozone))
na.numeric<-function(vector){
for(i in vector){
if (is.na(i)){
vector[i]<-mean(vector, na.rm=TRUE)
}
}
return(vector)
}
#
#############################################################################
#############################Problems Solved#################################
#############################################################################
#
#
#Step 1: Load the data
#We will use the air quality data set, which you should already have as part of your R installation.
#
local.airquality<-airquality
print(na.numeric(local.airquality$Ozone))
debug(na.numeric(local.airquality$ozone))
debug(na.numeric())
na.numeric<-function(input){
for(i in input){
if (is.na(i)){
input[i]<-mean(input, na.rm=TRUE)
}
}
return(input)
}
debug(na.numeric())
na.numeric<-function(input){
for(i in 1:ncol(input)){
data[is.na(input[,i]], i] <- mean(data[,i], na.rm=TRUE)
}
return(input)
}
#
#############################################################################
#############################IMPORTS SECTION#################################
#############################################################################
#
EnsurePackage("ggplot2")
EnsuredPackage("ggmap")
EnsuredPackage("RJSONI")
EnsuredPackage("Rcurl")
#
#############################################################################
#############################Problems Solved#################################
#############################################################################
#
#
#Step 1: Load the data
#We will use the air quality data set, which you should already have as part of your R installation.
#
local.airquality<-airquality
#
#Step 2: Clean the data
#After you load the data, there will be some NAs in the data. You need to figure out what to do
#about those nasty NAs.
#
local.airquality$Ozone
print(na.numeric(local.airquality$Ozone))
na.numeric<-function(input){
for(i in 1:ncol(input)){
data[is.na(input[,i]), i] <- mean(data[,i], na.rm=TRUE)
}
return(input)
}
#
#Step 2: Clean the data
#After you load the data, there will be some NAs in the data. You need to figure out what to do
#about those nasty NAs.
#
local.airquality$Ozone
print(na.numeric(local.airquality$Ozone))
length(local.airquality$Ozone)
#output:
#update history:
#############################################################################
#####################HW7: Viz Map HW: Median Income##########################
#############################################################################
#
#############################################################################
############################LOCAL FUNCTIONS##################################
#############################################################################
#
EnsurePackage<-function(x){
x<-as.character(x)
if (!require(x,character.only=TRUE)){
install.packages(pkgs=x, repos="http://cran.r-project.org")
require(x, character.only=TRUE)
}
}
Numberize <- function(inputVector)
{
inputVector <- gsub(",", "", inputVector)
inputVector <- gsub(" ", "", inputVector)
return(as.numeric(inputVector))
}
#Packages
EnsurePackage("gdata")
EnsurePackage("ggmap")
EnsurePackage("ggplot2")
EnsurePackage("here")
EnsurePackage("RJSONIO")
EnsurePackage("mapproj")
EnsurePackage("RCurl")
#DataSets
getwd()
here::here()
EnsurePackage("here")
here::here()
install.packages("here")
EnsurePackage("here")
#DataSets
getwd()
here::here()
csv_import<-read.csv("MedianZIP-3.csv") #moved csv file to the folder R wants it in
csv_import<-read.csv("~\MedianZIP-3.csv") #moved csv file to the folder R wants it in
csv_import<-read.csv("~/MedianZIP-3.csv") #moved csv file to the folder R wants it in
csv_import<-read.csv("MedianZIP-3.csv") #moved csv file to the folder R wants it in
here::here()
csv_import<-read.csv("MedianZIP-3.csv") #moved csv file to the folder R wants it in
View(csv_import)
View(csv_import)
#windows must be placed in users Documents folder C:\Users\Users\username
#mac must be placed in Users root folder Users\username
csv_import<-read.csv("MedianZIP-3.csv" stringsAsFactors = FALSE)
#windows must be placed in users Documents folder C:\Users\Users\username
#mac must be placed in Users root folder Users\username
csv_import<-read.csv("MedianZIP-3.csv", stringsAsFactors = FALSE)
View(csv_import)
View(csv_import)
csv_import
map.zipIncome<-map.zipIncome+geom_point(data=step3_df, aes(x=longitude[i], y=latitude[i]), alpha=.5, color=income[i], size=4)
source('~/github/IST687-Data-Science/HW7/LewisDB_HW7.R')
#output:
#update history:
#############################################################################
#####################HW7: Viz Map HW: Median Income##########################
#############################################################################
#
#############################################################################
############################LOCAL FUNCTIONS##################################
#############################################################################
#
dedot <- function(inputVector){
inputVector <- gsub("\\.","",csv_import)
}
EnsurePackage<-function(x){
x<-as.character(x)
if (!require(x,character.only=TRUE)){
install.packages(pkgs=x, repos="http://cran.r-project.org")
require(x, character.only=TRUE)
}
}
Numberize <- function(inputVector){
inputVector <-gsub(",","",inputVector)
inputVector <- gsub(" ", "", inputVector)
inputVector <-  as.numeric(inputVector)
}
#
#############################################################################
#############################IMPORTS SECTION#################################
#############################################################################
#Packages#
EnsurePackage("compare")
EnsurePackage("ggmap")
EnsurePackage("ggplot2")
EnsurePackage("mapproj")
EnsurePackage("sqldf")
EnsurePackage("stringr")
EnsurePackage("reprex")
EnsurePackage("zipcode")
#DataSets#
###Works on my windows 10 and mac machines by hitting the source button#
###[sets working directory to the script folder]#
this.dir <- dirname(parent.frame(2)$ofile)
setwd(this.dir)
#csv_import<-read.csv("MedianZIP-3.csv", stringsAsFactors = FALSE)
csv_import<-read.csv("Median-Cleaned.csv", stringsAsFactors = FALSE)
#turn the col names to lowercase#
colnames(csv_import)<-tolower(colnames(csv_import))
csv_import<-data.frame(sapply(csv_import, Numberize))
#fix the zip column length#
csv_import$zip<-str_pad(csv_import$zip, 5, "left","0")
#generate zipcode data frame#
data(zipcode)
#perform a merge based on zipcode col#
zipcode_joincsv<-merge(x=zipcode, y=csv_import, by="zip")
#sort by abv
colnames(zipcode_joincsv)[3]<-"abv"
zipcode_joincsv$abv<-sort(zipcode_joincsv$abv)
#Restrict to Lower 48 States (excluding all US territories)#
zipcode_joincsv<-data.frame(sqldf("SELECT *
FROM zipcode_joincsv
WHERE abv NOT IN ('AK', 'HI', 'DC')", row.names=TRUE))
#
#Step 2: Show the income & population per state
##1) Create a simpler dataframe, with just the average median income and the the population for each state.
##2) Add the state abbreviations and the state names as new columns (make sure the state names are all lower case)#
#create a vector filled with the 50 states, than clip AK and HI
states<-tolower(state.name)
states<-states[-2]
states<-states[-10]
#generate a vector filled with the sates abreviations
abv<-state.abb
abv<-abv[-2]
abv<-abv[-10]
#places state and abv into a data frame#
step2_df<-data.frame(states, abv)
#sums the population by states and puts them in the data frame#
population<-sqldf("SELECT sum(pop) AS 'pop'
FROM zipcode_joincsv
GROUP BY abv")
#generates the medium income by state and stores it into a vector#
income<-sqldf("SELECT AVG(median) AS 'income'
FROM zipcode_joincsv
GROUP BY abv")
#reformat data frame with all fields#
step2_df<-data.frame(states,abv,population,income)
##3) Show the U.S. map, representing the color with the average median income of that state
#
us<-map_data("state")
map.incomeColor<-ggplot(step2_df,aes(map_id=states))
map.incomeColor<-map.incomeColor+ geom_map(map=us, aes(fill=income))
map.incomeColor<-map.incomeColor+expand_limits(x=us$long, y=us$lat)
map.incomeColor<-map.incomeColor+coord_map()+ggtitle("States by Average Median Income")
map.incomeColor
##4) Create a second map with color representing the population of the state
#
us<-map_data("state")
map.popColor<-ggplot(step2_df,aes(map_id=states))
map.popColor<-map.popColor+ geom_map(map=us, aes(fill=pop))
map.popColor<-map.popColor+expand_limits(x=us$long, y=us$lat)
map.popColor<-map.popColor+coord_map()+ggtitle("States by Population")
map.popColor
#
#Step 3: Show the income per zip code
##1) Have draw each zip code on the map, where the color of the dota is based on the median income. To make the map look appealing, have the background of the map be black.
#
#Create a frame of all the data from this hw#
step3_df<-data.frame(as.character(tolower(state.name)),as.character(state.abb))
colnames(step3_df)<-c("state", "abv")
step3_df<-data.frame(sqldf("SELECT *
FROM step3_df
WHERE abv NOT IN ('AK', 'HI', 'DC')", row.names=TRUE))
step3_df<-dplyr::left_join(zipcode_joincsv, step3_df, by="abv")
step3_df$state<-sapply(step3_df$state,as.character)
step3_df<-step3_df[,c(9,3,2,1,4,5,6,7,8)]
rownames(step3_df)<-NULL
#show each zipcode on the map where color of dot is based on mean income#
us<-map_data("state")
map.zipIncome<-ggplot(step3_df, aes(map_id=state))
map.zipIncome<-map.zipIncome+geom_map(map=us, color="white")
map.zipIncome<-map.zipIncome+expand_limits(x=us$long, y=us$lat)
map.zipIncome<-map.zipIncome+coord_map() + ggtitle("Map of US Zipcodes Colored by Income")
map.zipIncome
map.zipIncome<-map.zipIncome+geom_point(data=step3_df, aes(x=longitude[1], y=latitude[1]), alpha=.5, color=income[1], size=4)
map.zipIncome
map.zipIncome<-map.zipIncome+geom_point(data=step3_df, aes(x=longitude[1], y=latitude[1]), alpha=.5, color=income, size=4)
map.zipIncome
#show each zipcode on the map where color of dot is based on mean income#
us<-map_data("state")
map.zipIncome<-ggplot(step3_df, aes(map_id=state))
map.zipIncome<-map.zipIncome+geom_map(map=us, color="white")
map.zipIncome<-map.zipIncome+expand_limits(x=us$long, y=us$lat)
map.zipIncome<-map.zipIncome+coord_map() + ggtitle("Map of US Zipcodes Colored by Income")
map.zipIncome
map.zipIncome<-map.zipIncome+geom_point(data=step3_df, aes(x=longitude[1], y=latitude[1] color=income[1]), alpha=.5, size=4
map.zipIncome<-map.zipIncome+geom_point(data=step3_df, aes(x=longitude[1], y=latitude[1], color=income[1]), alpha=.5, size=4
map.zipIncome
#show each zipcode on the map where color of dot is based on mean income#
us<-map_data("state")
map.zipIncome<-ggplot(step3_df, aes(map_id=state))
map.zipIncome<-map.zipIncome+geom_map(map=us, color="white")
map.zipIncome<-map.zipIncome+expand_limits(x=us$long, y=us$lat)
map.zipIncome<-map.zipIncome+coord_map() + ggtitle("Map of US Zipcodes Colored by Income")
map.zipIncome
map.zipIncome<-map.zipIncome+geom_point(data=step3_df, aes(x=longitude[1], y=latitude[1], color=income[1]), alpha=.5, size=4)
map.zipIncome
#show each zipcode on the map where color of dot is based on mean income#
us<-map_data("state")
map.zipIncome<-ggplot(step3_df, aes(map_id=state))
map.zipIncome<-map.zipIncome+geom_map(map=us, color="white")
map.zipIncome<-map.zipIncome+expand_limits(x=us$long, y=us$lat)
map.zipIncome<-map.zipIncome+coord_map() + ggtitle("Map of US Zipcodes Colored by Income")
map.zipIncome
map.zipIncome<-map.zipIncome+geom_point(data=step3_df, aes(x=longitude[1], y=latitude[1]), color=income[1], alpha=.5, size=4)
map.zipIncome
map.zipIncome <- map.zipIncome + geom_point(data=step3_df, aes(x=longitude, y=latitude,color=income), alpha=.5, size=4)
map.zipIncome
#show each zipcode on the map where color of dot is based on mean income#
us<-map_data("state")
map.zipIncome<-ggplot(step3_df, aes(map_id=state))
map.zipIncome<-map.zipIncome+geom_map(map=us, color="white")
map.zipIncome<-map.zipIncome+expand_limits(x=us$long, y=us$lat)
map.zipIncome<-map.zipIncome+coord_map() + ggtitle("Map of US Zipcodes Colored by Income")
map.zipIncome
restore<-map.zipIncome
View(step3_df)
map.zipIncome+geom_point(data=step3_df, aes(x=longitude[i], y=latitude[i],color=income[i]), alpha=.5, size=4)
map.zipIncome+geom_point(data=step3_df, aes(x=longitude[1], y=latitude[1],color=income[1]), alpha=.5, size=4)
map.zipIncome+geom_point(data=step3_df, aes(x=longitude[1], y=latitude[1]), alpha=.5, size=4 ,color=income[1])
#show each zipcode on the map where color of dot is based on mean income#
us<-map_data("state")
map.zipIncome<-ggplot(step3_df, aes(map_id=state))
map.zipIncome<-map.zipIncome+geom_map(map=us, color="white")
map.zipIncome<-map.zipIncome+expand_limits(x=us$long, y=us$lat)
map.zipIncome<-map.zipIncome+coord_map() + ggtitle("Map of US Zipcodes Colored by Income")
map.zipIncome
#
#Step 4: Show Zip Code Density
##1) Now generate a different map, one where we can easily see where there are lots of zip codes, and where there are few (using the stat_density2dâ function).
#
us<-map_data("state")
map.zipDensity<-ggplot(step3_df, aes(map_id=state))
map.zipDensity<-map.zipDensity+geom_map(map=us, color="white")
map.zipDensity<-map.zipDensity+expand_limits(x=us$long, y=us$lat)
map.zipDensity<-map.zipDensity+coord_map() + ggtitle("Map of US Zipcodes Colored by Zipcode Intensity")
map.zipDensity
#
#Step 5: Zoom in to the region around NYC
##1) Repeat steps 3 & 4, but have the image / map be of the northeast U.S. (centered around New York).
#
us<-map_data("state")
map.regionView<-ggplot(step3_df, aes(map_id=state))
map.regionView<-map.regionView+geom_map(map=us, color="white")
map.regionView<-map.regionView+expand_limits(x=us$long, y=us$lat)
map.regionView<-map.regionView+coord_map() + ggtitle("Map of North East Region Colored by Income")
map.regionView
